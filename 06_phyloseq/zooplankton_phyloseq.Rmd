---
title: "Great Lakes Zooplankton Metabarcoding (phyloseq)"
output:
  html_document:
    toc: true
    toc_depth: 3
    number_sections: true
    theme: flatly
    df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  fig.width = 10,
  fig.height = 6
)
```

# Overview

This R Markdown is designed to analyze Great Lakes zooplankton metabarcoding data using phyloseq objects for the Folmer, Leray, and 18S markers, plus a morphology-based phyloseq object. The analysis is highly configurable via the **Configuration** section so you can quickly swap markers, taxonomic ranks, taxa subsets, and comparisons.

Key ideas:
- **Presence/absence** data are used whenever comparing across markers or between markers and morphology.
- **Morphology comparisons** only use samples with morphological data.
- **Consistent Lake order** (west to east) is enforced in plots.
- **Shared helper functions** are defined to standardize common steps.

# Configuration

```{r config}
# ---- Paths ----
base_dir <- "06_phyloseq"
metadata_file <- file.path(base_dir, "zoop96_metadata.csv")
ps_files <- list(
  `18S`   = file.path(base_dir, "18S_dadaoriginal.rds"),
  Folmer  = file.path(base_dir, "Folmer_dadaoriginal.rds"),
  Leray   = file.path(base_dir, "mICOintF_dadaoriginal.rds"),
  Morph   = file.path(base_dir, "morph_ps_integer.rds")
)

# ---- Analysis toggles ----
rank_use <- "Genus"         # ASV level is handled by rank_use = NULL
presence_absence <- FALSE   # For cross-marker or marker+morph comparisons, set TRUE
min_prevalence <- 0         # 0-1 proportion of samples; 0 means no filtering

# ---- Subsetting ----
taxa_include <- NULL        # Example: c("Calanoida")
taxa_exclude <- NULL        # Example: c("Rotifera")

# ---- Marker selection ----
markers_to_use <- c("Folmer", "Leray", "18S", "Morph")
marker_pairs <- list(
  c("Folmer", "Leray"),
  c("Folmer", "18S"),
  c("Leray", "18S"),
  c("Folmer", "Morph"),
  c("Leray", "Morph"),
  c("18S", "Morph")
)

# ---- Lake ordering (west -> east) ----
lake_order <- c("Superior", "Michigan", "Huron", "Erie", "Ontario")

# ---- Colors ----
lake_colors <- c(
  Superior = "#1b9e77",
  Michigan = "#d95f02",
  Huron    = "#7570b3",
  Erie     = "#e7298a",
  Ontario  = "#66a61e"
)

marker_colors <- c(
  Folmer = "#386cb0",
  Leray  = "#fdb462",
  `18S`  = "#7fc97f",
  Morph  = "#ef3b2c"
)

# ---- Metadata columns ----
metadata_id_col <- "Sample_ID"
```

# Libraries

```{r libraries}
required_pkgs <- c(
  "phyloseq", "tidyverse", "vegan", "ggplot2", "patchwork",
  "microbiome", "ANCOMBC", "ggVennDiagram", "scales",
  "geosphere", "sf", "ape", "phangorn", "DECIPHER",
  "unmarked", "spOccupancy", "RColorBrewer"
)

install_if_missing <- function(pkgs) {
  missing <- pkgs[!pkgs %in% installed.packages()[, "Package"]]
  if (length(missing) > 0) {
    message("Installing missing packages: ", paste(missing, collapse = ", "))
    install.packages(missing)
  }
}

install_if_missing(required_pkgs)

library(phyloseq)
library(tidyverse)
library(vegan)
library(ggplot2)
library(patchwork)
library(microbiome)
library(ANCOMBC)
library(ggVennDiagram)
library(scales)
library(geosphere)
library(sf)
library(ape)
library(phangorn)
library(DECIPHER)
library(unmarked)
library(spOccupancy)
library(RColorBrewer)
```

# Load data

```{r load-data}
read_rds_safe <- function(path) {
  if (file.exists(path)) return(readRDS(path))
  alt <- sub("\.rds$", "", path)
  if (file.exists(alt)) return(readRDS(alt))
  stop("File not found: ", path)
}

metadata <- read.csv(metadata_file, stringsAsFactors = FALSE)
metadata <- metadata %>%
  mutate(
    Lake = factor(Lake, levels = lake_order),
    Morph_avail = toupper(Morph_avail)
  )

ps_list <- list(
  `18S`   = read_rds_safe(ps_files[["18S"]]),
  Folmer  = read_rds_safe(ps_files[["Folmer"]]),
  Leray   = read_rds_safe(ps_files[["Leray"]]),
  Morph   = read_rds_safe(ps_files[["Morph"]])
)

# Attach metadata to each phyloseq object
attach_metadata <- function(ps, metadata_df, only_morph = FALSE) {
  smp <- sample_names(ps)
  df <- metadata_df %>% filter(.data[[metadata_id_col]] %in% smp)
  if (only_morph) {
    df <- df %>% filter(Morph_avail == "YES")
  }
  rownames(df) <- df[[metadata_id_col]]
  sample_data(ps) <- sample_data(df)
  ps
}

ps_list$`18S` <- attach_metadata(ps_list$`18S`, metadata)
ps_list$Folmer <- attach_metadata(ps_list$Folmer, metadata)
ps_list$Leray <- attach_metadata(ps_list$Leray, metadata)
ps_list$Morph <- attach_metadata(ps_list$Morph, metadata, only_morph = TRUE)

# Ensure morphology samples are only those with morph data
ps_list$Morph <- prune_samples(sample_data(ps_list$Morph)$Morph_avail == "YES", ps_list$Morph)

# Ensure sample_data has NA for missing spatial data, but keep rows
# (already handled in metadata; missing values should be NA)
```

# Helper functions

```{r helpers}
# Convert to presence/absence
make_presence_absence <- function(ps) {
  transform_sample_counts(ps, function(x) as.numeric(x > 0))
}

# Agglomerate to rank if requested
agglomerate_rank <- function(ps, rank = NULL) {
  if (is.null(rank)) return(ps)
  if (!rank %in% colnames(tax_table(ps))) {
    stop("Rank not found in tax_table: ", rank)
  }
  tax_glom(ps, taxrank = rank, NArm = TRUE)
}

# Subset taxa by include/exclude list (matches on any taxonomy rank)
subset_taxa_by_name <- function(ps, include = NULL, exclude = NULL) {
  tt <- as.data.frame(tax_table(ps))
  keep <- rep(TRUE, nrow(tt))
  if (!is.null(include)) {
    inc <- apply(tt, 1, function(x) any(x %in% include))
    keep <- keep & inc
  }
  if (!is.null(exclude)) {
    exc <- apply(tt, 1, function(x) any(x %in% exclude))
    keep <- keep & !exc
  }
  prune_taxa(keep, ps)
}

# Filter by minimum prevalence
filter_prevalence <- function(ps, min_prev = 0) {
  if (min_prev <= 0) return(ps)
  prev <- apply(otu_table(ps) > 0, 1, mean)
  prune_taxa(prev >= min_prev, ps)
}

# Standard prep
prep_ps <- function(ps,
                    rank = rank_use,
                    presence = presence_absence,
                    include = taxa_include,
                    exclude = taxa_exclude,
                    min_prev = min_prevalence) {
  ps2 <- ps
  if (presence) ps2 <- make_presence_absence(ps2)
  ps2 <- agglomerate_rank(ps2, rank = rank)
  ps2 <- subset_taxa_by_name(ps2, include = include, exclude = exclude)
  ps2 <- filter_prevalence(ps2, min_prev = min_prev)
  ps2
}

# Standard plot theme
theme_phylo <- function() {
  theme_minimal(base_size = 12) +
    theme(
      panel.grid.minor = element_blank(),
      axis.text.x = element_text(angle = 45, hjust = 1)
    )
}
}

# Marker-specific objects

```{r prep-markers}
ps_use <- ps_list[markers_to_use]
ps_use <- lapply(ps_use, prep_ps)
```

# 1) Overall biodiversity barplots

```{r barplots, fig.height=8}
plot_bar_by_lake <- function(ps, title, rank = rank_use) {
  p <- plot_bar(ps, x = "Sample_ID", fill = rank) +
    facet_wrap(~Lake, scales = "free_x") +
    scale_x_discrete(labels = NULL) +
    theme_phylo() +
    ggtitle(title)
  p
}

barplots <- lapply(names(ps_use), function(m) {
  plot_bar_by_lake(ps_use[[m]], paste("Marker:", m))
})

wrap_plots(barplots, ncol = 1)
```

# 2) Alpha diversity

```{r alpha-diversity}
alpha_metrics <- function(ps, use_abundance = TRUE) {
  if (!use_abundance) {
    ps <- make_presence_absence(ps)
  }
  df <- estimate_richness(ps, measures = c("Observed", "InvSimpson", "Chao1"))
  df <- cbind(df, sample_data(ps))
  df
}

# Example: marker-wise alpha diversity by lake
alpha_plots <- lapply(names(ps_use), function(m) {
  df <- alpha_metrics(ps_use[[m]], use_abundance = TRUE)
  ggplot(df, aes(x = Lake, y = Observed, fill = Lake)) +
    geom_boxplot() +
    scale_fill_manual(values = lake_colors) +
    theme_phylo() +
    ggtitle(paste("Observed richness -", m))
})

wrap_plots(alpha_plots, ncol = 1)

# Pairwise comparisons between markers using presence/absence
alpha_pa <- lapply(names(ps_use), function(m) alpha_metrics(ps_use[[m]], use_abundance = FALSE))
```

# 3) ANCOM-BC (differential abundance)

```{r ancombc}
# ANCOM-BC is appropriate for count data and can be used for differential abundance
# across lakes or other covariates. It is not suitable when mixing markers, and should
# be used within a marker (or within morphology) due to differing primer biases.

run_ancombc <- function(ps, formula = "Lake") {
  ps <- prune_taxa(taxa_sums(ps) > 0, ps)
  ancombc2::ancombc2(
    data = ps,
    fix_formula = formula,
    rand_formula = NULL,
    p_adj_method = "BH",
    prv_cut = 0.1,
    lib_cut = 1000,
    group = NULL,
    struc_zero = TRUE,
    neg_lb = TRUE
  )
}

# Example (within a marker):
# ancom_res <- run_ancombc(ps_use[["18S"]], formula = "Lake")
```

# 4) Beta diversity (ordination + PERMANOVA)

```{r beta-diversity}
run_beta <- function(ps, dist = "bray", method = "PCoA") {
  ord <- ordinate(ps, method = method, distance = dist)
  p <- plot_ordination(ps, ord, color = "Lake") +
    scale_color_manual(values = lake_colors) +
    theme_phylo()
  list(ord = ord, plot = p)
}

# Presence/absence (Jaccard)
ps_pa <- lapply(ps_use, make_presence_absence)

beta_plots <- lapply(names(ps_pa), function(m) {
  res <- run_beta(ps_pa[[m]], dist = "jaccard")
  res$plot + ggtitle(paste("Jaccard PCoA -", m))
})

wrap_plots(beta_plots, ncol = 1)

# Abundance (Bray-Curtis)
beta_plots_bc <- lapply(names(ps_use), function(m) {
  res <- run_beta(ps_use[[m]], dist = "bray")
  res$plot + ggtitle(paste("Bray-Curtis PCoA -", m))
})

wrap_plots(beta_plots_bc, ncol = 1)

# PERMANOVA example
run_permanova <- function(ps, dist = "bray", formula = "Lake") {
  d <- distance(ps, dist)
  meta <- data.frame(sample_data(ps))
  adonis2(d ~ ., data = meta[, all.vars(as.formula(formula)), drop = FALSE])
}
```

# 5) Taxa driving differences

```{r taxa-drivers}
# Identify taxa with high indicator values across lakes
# Uses multipatt from indicspecies if desired; here we use simple prevalence differences

taxa_prevalence <- function(ps) {
  otu <- otu_table(ps)
  prev <- apply(otu > 0, 1, mean)
  data.frame(taxa = taxa_names(ps), prevalence = prev)
}

# Example: prevalence by lake
prevalence_by_lake <- function(ps) {
  otu <- otu_table(ps)
  meta <- data.frame(sample_data(ps))
  taxa <- taxa_names(ps)
  res <- lapply(levels(meta$Lake), function(lk) {
    idx <- meta$Lake == lk
    prev <- apply(otu[, idx, drop = FALSE] > 0, 1, mean)
    data.frame(taxa = taxa, lake = lk, prevalence = prev)
  })
  bind_rows(res)
}

# Example usage:
# prev_lake <- prevalence_by_lake(ps_use[["18S"]])
```

# 6) Geographic analyses

```{r geography}
# Isolation by distance (within lakes) using Mantel tests
run_isolation_by_distance <- function(ps, dist_metric = "jaccard") {
  meta <- data.frame(sample_data(ps))
  meta <- meta %>% filter(!is.na(Latitude), !is.na(Longitude))
  ps <- prune_samples(rownames(meta), ps)
  geo_dist <- distm(meta[, c("Longitude", "Latitude")])
  comm_dist <- as.matrix(distance(ps, dist = dist_metric))
  list(
    mantel = mantel(as.dist(comm_dist), as.dist(geo_dist)),
    geo_dist = geo_dist,
    comm_dist = comm_dist
  )
}

# Example:
# iso_res <- run_isolation_by_distance(ps_pa[["18S"]])
```

# 7) Phylogenetic trees (per marker + morph)

```{r phylogenetic-trees}
# Build tree from ASV sequences if refseq is available in phyloseq object
build_tree_from_ps <- function(ps) {
  if (!"refseq" %in% slotNames(ps) || is.null(refseq(ps))) {
    stop("No refseq found in phyloseq object; provide sequences to build tree.")
  }
  dna <- DNAStringSet(refseq(ps))
  names(dna) <- taxa_names(ps)
  aln <- AlignSeqs(dna, anchor = NA)
  phydat <- phangorn::phyDat(as.matrix(aln), type = "DNA")
  dm <- dist.ml(phydat)
  tree_nj <- NJ(dm)
  fit <- pml(tree_nj, phydat)
  fit <- optim.pml(fit, model = "GTR", optInv = TRUE, optGamma = TRUE)
  fit$tree
}

# Example:
# tree_18S <- build_tree_from_ps(ps_list[["18S"]])
```

# 8) Venn diagrams of overlap in taxa

```{r venn-diagrams}
get_taxa_set <- function(ps, rank = rank_use) {
  if (is.null(rank)) return(taxa_names(ps))
  tt <- as.data.frame(tax_table(ps))
  unique(tt[[rank]])
}

# Example: overlap at Genus level
taxa_sets <- lapply(ps_use, get_taxa_set)

ggVennDiagram(taxa_sets) + theme_phylo()
```

# 9) Combined biodiversity (presence/absence only)

```{r combined-biodiversity}
# Combine taxa presence across markers (union) at selected rank
combined_presence_matrix <- function(ps_list_in, rank = rank_use) {
  tables <- lapply(ps_list_in, function(ps) {
    ps_pa <- make_presence_absence(agglomerate_rank(ps, rank))
    otu <- as.data.frame(t(otu_table(ps_pa)))
    otu$Sample_ID <- rownames(otu)
    otu
  })
  reduce(tables, full_join, by = "Sample_ID") %>%
    replace(is.na(.), 0) %>%
    column_to_rownames("Sample_ID")
}

combined_pa <- combined_presence_matrix(ps_use)

# Optional: make a pseudo-phyloseq object for plotting
combined_ps <- phyloseq(
  otu_table(as.matrix(t(combined_pa)), taxa_are_rows = TRUE),
  sample_data(metadata)
)
```

# 10) Taxa-of-interest analyses

```{r taxa-of-interest}
interesting_taxa <- c("Calanoida", "Copepoda", "Leptodiaptomus")

# Example: relative abundance or prevalence by marker
taxa_focus <- lapply(ps_use, function(ps) subset_taxa_by_name(ps, include = interesting_taxa))

# Prevalence by marker
focus_prev <- lapply(names(taxa_focus), function(m) {
  df <- taxa_prevalence(taxa_focus[[m]])
  df$marker <- m
  df
}) %>% bind_rows()

ggplot(focus_prev, aes(x = marker, y = prevalence, fill = marker)) +
  geom_col() +
  scale_fill_manual(values = marker_colors) +
  theme_phylo() +
  ggtitle("Prevalence of taxa of interest by marker")
```

# Marker bias analyses

```{r marker-bias}
# Identify taxa that are preferentially detected by a marker
# This section uses prevalence differences across markers

marker_prevalence <- function(ps_list_in, rank = rank_use) {
  bind_rows(lapply(names(ps_list_in), function(m) {
    ps <- agglomerate_rank(ps_list_in[[m]], rank)
    prev <- taxa_prevalence(ps)
    prev$marker <- m
    prev
  }))
}

prev_by_marker <- marker_prevalence(ps_use)

# Example: top taxa by marker prevalence
prev_summary <- prev_by_marker %>%
  group_by(marker) %>%
  arrange(desc(prevalence)) %>%
  slice_head(n = 20)

prev_summary
```

# 11) Variance partitioning + RDA

```{r variance-partitioning}
# Hellinger transform for abundance matrices
hellinger <- function(ps) {
  otu <- as.data.frame(t(otu_table(ps)))
  decostand(otu, method = "hellinger")
}

# RDA with key variables (update formula as needed)
run_rda <- function(ps) {
  otu_hel <- hellinger(ps)
  meta <- data.frame(sample_data(ps))
  rda(otu_hel ~ Lake + Mesh + Year_Sampled + Month_Sampled, data = meta)
}

# Variance partitioning example
run_varpart <- function(ps) {
  otu_hel <- hellinger(ps)
  meta <- data.frame(sample_data(ps))
  env1 <- meta[, c("Lake", "Mesh"), drop = FALSE]
  env2 <- meta[, c("Year_Sampled", "Month_Sampled"), drop = FALSE]
  varpart(otu_hel, env1, env2)
}
```

# 12) Occupancy modeling

```{r occupancy-modeling}
# Multi-method detection probability across markers
# Construct detection history matrix: samples (rows) x markers (columns)

build_detection_history <- function(ps_list_in, rank = rank_use) {
  det <- lapply(ps_list_in, function(ps) {
    ps_pa <- make_presence_absence(agglomerate_rank(ps, rank))
    otu <- as.data.frame(t(otu_table(ps_pa)))
    as.matrix(otu > 0) * 1
  })
  # For detection, collapse taxa to any detection per sample
  det2 <- lapply(det, function(m) rowSums(m) > 0)
  det_df <- as.data.frame(det2)
  det_df$Sample_ID <- rownames(det[[1]])
  det_df
}

# Example occupancy across lakes with unmarked
# detection_history <- build_detection_history(ps_use)
# umf <- unmarkedFrameOccu(y = as.matrix(detection_history[, names(ps_use)]),
#                          siteCovs = metadata)
# occu(~1 ~ Lake, data = umf)
```

# 13) Additional standard analyses

```{r additional-analyses}
# Rarefaction curves
plot_rarefaction <- function(ps) {
  otu <- as.data.frame(t(otu_table(ps)))
  rarecurve(otu, step = 100, label = FALSE)
}

# Example usage:
# plot_rarefaction(ps_use[["18S"]])
```

# Notes & suggested workflow

1. Start with **rank_use = "Genus"** and no taxa filters to view overall patterns.
2. Switch `presence_absence` to `TRUE` when comparing markers or marker+morphology.
3. Use `taxa_include`/`taxa_exclude` to focus on groups like **Calanoida**, **Copepoda**, and **Leptodiaptomus**.
4. For cross-marker comparisons, rely on **Jaccard** distances and **presence/absence**.
5. For within-marker ecology, use **Bray-Curtis** and abundance-based alpha diversity.

# Questions to refine

- Are ASV sequences stored in the phyloseq `refseq` slot? If not, provide FASTA paths so the tree-building chunk can work.
- Should analyses emphasize lakes or station-level comparisons by default?
- Do you want separate HTML outputs per marker (parameterized Rmd), or a single combined report?
